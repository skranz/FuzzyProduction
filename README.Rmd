# FuzzyProduction

WORK IN PROGRESS -- EVERYTHING MAY SUBSTANTIALLY CHANGE

Leading example: Assume you want to use AI to extract and characterize all tables from a PDF of a scientific article. You want an HTML version of each table, but also several characterizations and classifications. E.g. detect if the table shows regression results, then detect each separately shown regression and map it to a regression commands in the code of the article's reproduction package.

Likely this process will be performed in multiple steps, creating intermediate results, that we call `products`. E.g. the first product may just be a data set that lists all tables found in the PDF. The next product may be a wider data set that adds title, table notes and table HTML for each table and so on. 

For each product there might be different ways to create it yielding different `versions`. E.g. using different AI models, different prompts, different intermediate product versions as inputs, using a particular heuristic instead of AI,  ...

AI makes errors and some processes may yield systematically better versions than others. Also costs in terms of time and money, might differ substantially between versions. Maybe some day (soon?) affordable AI is good enough that for a non-critical application such errors can be ignored, but currently it is still an issue.  

This package shall guide and help dealing with such fuzzy AI production chains:
  
- Specify products and versions
  
- Help generating prompts and structured response objects that create products using intermediate products.
  
- Help testing the quality and consistency of different versions of a product.
  
It is not clear how much functionality will be part of this package and how much will be part of each concrete application.   

## Some variable names and terms
  
**pid** product id

**vid** version id

**var** a variable name in a classic product that will just be a data set / table


  
Let's define some names:

**input** The PDF of the article. `input` may be equal to an article ID.

**process (proc)** identifies the process to convert the input (the pdf) into the output (the HTM tables), e.g. `procid="gemini-2.0-flash-prompt1"`.

**product (prod)** a label for the general class of outputs that shall be generated e.g. `prod = "all_html_tables"`.  

**output** the concrete output generated by running a process once on an input.

In our package, we call each such process a **road**. I am aware that *road* may not be the most fitting english expression but it is short and not as commonly used in other coding contexts, like process or pipe. The result of a particular road is called a **product**. 

AI task's will not always yield precise results. But different *roads* to the desired *product* may work differently well.


```{r}
# Products and intermediate products
product_defs(
  prod_def(
    "tab_base"
    fields = prod_fields(
      prod_field("artid", key=TRUE),
      prod_field("tabid", "Table 1", key=TRUE),
      prod_field("tabnum", 1L)
    )
  ),
  prod_def(
    "tab_title_note",
    widens = "tab_base", # means same keys, extends fields
    fields = prod_fields(
      prod_field("tabtitle", "Table 1: Regression analysis")
      prod_field("tabnote", "")
    )
  ),
  prod_def(
    "tab_html",
    widens = "tab_title_note",
    fields = prod_fields(
      prod_field("tabhtml", type="html_table", descr="Normalized HTML table with cellid, row and col definitions.")
    )
  ),
  prod_def(
    "tab_type",
    widens = "tab_html",
    fields = prod_fields(
      prod_field("tab_has_reg", FALSE),
      prod_field("tab_has_did", FALSE)
      # And so on...
    )
  ),
  prod_def(
    "cell_base",
    # means 1 parent row can have multiple children rows
    parent = "tab_html",
    fields = prod_fields(
      prod_field("cellid", 1L, key=TRUE),
      prod_field("row",1L),
      prod_field("col",1L),
      prod_field("celltxt","")
    )
  ),
  prod_def(
    "cell_content_simple",
    widens = "cell_base",
    fields = prod_fields(
      prod_field("is_num", FALSE),
      prod_field("has_deci", FALSE),
      prod_field("braces", enum=c("", "(","[","{")),
      prod_field("has_sig_star", FALSE),
      prod_field("sig_star","*")
    ),
    descr ="Can be generated purely using heuristics from cell_base"
  ),
  prod_def(
    "tab_panel",
    parent = "tab_html",
    fields = prod_fields(
      prod_field("panelid","", key=TRUE),
      prod_field("panel_first_row", 1L),
      prod_field("panel_last_row", 2L)
    )
  ),
  prod_def(
    "cell_content",
    widens = "cell_content_simple",
    fields = prod_fields(
      prod_field("panelid", FALSE),
      prod_field("has_deci", FALSE),
      prod_field("braces", enum=c("", "(","[","{")),
      prod_field("has_sig_star", FALSE),
      prod_field("sig_star","*")
    ),
    descr ="Can be generated purely using heuristics from cell_base"
  ),
  
  prod_def(
    "cell_reg",
    widens = "cell_content",
    fields = prod_fields(
      prod_field("regnum", 1L),
      prod_field("reg_cell_type", 1L, enum=c("xvar","coef","se","p","t", "nobs", "depvar","regcol","other")),
      
    )
    
    
  )

  
  
  
)

  spec = arr_spec(
    
  )


)

step_graph('
  pdf -> tab_info,
  tab_info -> tab_html,
  (tab_info,tab_html) -> cell_info,
  (pdf, )

') 
```

There are many different ways to tackle this goal e.g. different AI models, different prompts, different inputs (image, pdf2text results, single pages, all in one) and so on.

Let's define some names:

**input** The PDF of the article. `input` may be equal to an article ID.

**process (proc)** identifies the process to convert the input (the pdf) into the output (the HTM tables), e.g. `procid="gemini-2.0-flash-prompt1"`.

**product (prod)** a label for the general class of outputs that shall be generated e.g. `prod = "all_html_tables"`.  

**output** the concrete output generated by running a process once on an input.

In our package, we call each such process a **road**. I am aware that *road* may not be the most fitting english expression but it is short and not as commonly used in other coding contexts, like process or pipe. The result of a particular road is called a **product**. 

AI task's will not always yield precise results. But different *roads* to the desired *product* may work differently well.
