# FILE: fp_report.R
# Make a an HTML report of fuzzy products


# ver_dirs will typically be generated by fp_all_ver_dirs

# Look at all prod_df in the ver_dirs and generate HTML report
# Arrange by prod_id, proc_id, ver_id
# Show prod_df data frames in as compact, striped HTML tables with y-scroll and x-scroll enabled. Possibly limit to max_rows and max_cols


# Helper function to escape HTML special characters
# Not exported.
.html_escape = function(text) {
  text = as.character(text)
  if (length(text) == 0) return("")
  text[is.na(text)] = ""
  return(text)
}

# Helper function to generate an HTML table from a data frame
# Not exported.
.df_to_html_table = function(df) {
  if (is.null(df) || NROW(df) == 0) {
    return("<p><em>No data available.</em></p>")
  }

  html = c("<table>", "<thead>", "<tr>")

  # Header
  for (col_name in names(df)) {
    html = c(html, paste0("<th>", .html_escape(col_name), "</th>"))
  }
  html = c(html, "</tr>", "</thead>", "<tbody>")

  # Body
  for (i in 1:NROW(df)) {
    html = c(html, "<tr>")
    # Using a vectorized approach for cells in a row is faster
    cells = sapply(df[i, ], function(cell_value) {
      if (is.na(cell_value)) {
        cell_text = "<em>NA</em>"
      } else {
        cell_text = .html_escape(cell_value)
      }
      paste0("<td>", cell_text, "</td>")
    })
    html = c(html, cells)
    html = c(html, "</tr>")
  }

  html = c(html, "</tbody>", "</table>")
  paste(html, collapse = "\n")
}

fp_report_css = function() {
  css = "
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; margin: 2em; color: #333; }
    h1 { color: #111; border-bottom: 2px solid #ccc; padding-bottom: 0.1em; }
    h2 { background-color: #eef; color: #333; padding: 0.1em; border-left: 5px solid #66b; margin-top: 0.1em;}
    .table-container { max-height: 600px; max-width: 100%; overflow: auto; border: 1px solid #ccc; margin-bottom: 0.5em; }
    table { border-collapse: collapse; font-size: 0.8em; white-space: nowrap; }
    th, td { border: 1px solid #ddd; padding: 4px 6px; text-align: left; vertical-align: top; }
    th { background-color: #f2f2f2; position: sticky; top: 0; z-index: 1; }
    tr:nth-child(even) { background-color: #f9f9f9; }
    tr:hover { background-color: #f1f1f1; }
    .trunc-info { font-style: italic; color: #888; font-size: 0.8em; margin-bottom: 1em;}
    em { color: #999; }
  "

}

#' Generate an HTML report for fuzzy products
#'
#' This function takes a set of version directories, loads the `prod_df.Rds`
#' from each, and compiles them into a single HTML report file. The report
#' is organized by product, process, and version. Each data frame is
#' displayed in a scrollable, styled table.
#'
#' @param ver_dirs A character vector of version directories. Typically generated by `fp_all_ok_ver_dirs`.
#' @param outfile The path for the output HTML file.
#' @param max_rows The maximum number of rows to display for each table.
#' @param max_cols The maximum number of columns to display for each table.
#' @param title The title of the HTML report.
#' @return The path to the created `outfile`, invisibly.
fp_html_report = function(ver_dirs, outfile=NULL, max_rows=100, max_cols=50, title = "Fuzzy Production Report") {
  restore.point("fp_html_report")


  if (length(ver_dirs) == 0) {
    cat("No version directories provided to fp_html_report.")
    return(invisible(NULL))
  }

  if (is.null(outfile)) {
    fp_dir = fp_ver_dir_to_fp_dir(ver_dirs[1])
    outfile = file.path(fp_dir, "fp_report.html")
  }

  # 1. Get info for all ver_dirs and sort them
  info_df = fp_ver_dir_to_ids(ver_dirs)
  info_df = dplyr::arrange(info_df, .data$prod_id, .data$proc_id, .data$ver_ind)

  # 2. Start building HTML content
  css = fp_report_css()

  html_head = paste0(
    "<!DOCTYPE html><html><head><meta charset='UTF-8'><title>", .html_escape(title), "</title>",
    "<style>", css, "</style></head><body><h1>", .html_escape(title), "</h1>"
  )

  html_body_parts = c()

  # 3. Iterate through sorted dirs, load data, and generate HTML for each table
  for (i in 1:NROW(info_df)) {
    row = info_df[i, ]
    ver_dir = row$ver_dir

    header = paste(row$prod_id, row$proc_id, paste0("v", row$ver_ind), sep = " / ")
    html_body_parts = c(html_body_parts, paste0("<h2>", .html_escape(header), "</h2>"))

    # Load prod_df
    df = tryCatch({
      fp_load_prod_df(ver_dir)
    }, error = function(e) {
      warning("Could not load prod_df from ", ver_dir, ": ", e$message)
      return(NULL)
    })

    if (is.null(df)) {
       html_body_parts = c(html_body_parts, "<p><em>Could not load data.</em></p>")
       next
    }

    # Truncate if necessary
    orig_rows = NROW(df)
    orig_cols = NCOL(df)

    df_display = df
    truncated = FALSE
    trunc_msg = c()

    if (orig_rows > max_rows) {
      df_display = df_display[1:max_rows, ]
      trunc_msg = c(trunc_msg, paste0("rows truncated to ", max_rows, " (from ", orig_rows, ")"))
      truncated = TRUE
    }
    if (orig_cols > max_cols) {
      df_display = df_display[, 1:max_cols, drop = FALSE]
      trunc_msg = c(trunc_msg, paste0("columns truncated to ", max_cols, " (from ", orig_cols, ")"))
      truncated = TRUE
    }

    # Generate table HTML
    table_html = .df_to_html_table(df_display)
    html_body_parts = c(html_body_parts, "<div class='table-container'>", table_html, "</div>")

    # Add truncation info message if needed
    if (truncated) {
        msg = paste0("<p class='trunc-info'>Note: ", paste(trunc_msg, collapse=", "), ".</p>")
        html_body_parts = c(html_body_parts, msg)
    }
  }

  html_foot = "</body></html>"

  # 4. Combine all parts and write to file
  final_html = paste(c(html_head, html_body_parts, html_foot), collapse="\n")
  writeLines(final_html, outfile)

  cat("HTML report written to:", outfile, "\n")
  invisible(outfile)
}
