# FILE: fp_report.R
# Make a an HTML report of fuzzy products


# ver_dirs will typically be generated by fp_all_ver_dirs

# Look at all prod_df in the ver_dirs and generate HTML report
# Arrange by prod_id, proc_id, ver_id
# Show prod_df data frames in as compact, striped HTML tables with y-scroll and x-scroll enabled. Possibly limit to max_rows and max_cols


# Helper function to escape HTML special characters
# Not exported.
.html_escape = function(text) {
  text = as.character(text)
  if (length(text) == 0) return("")
  text[is.na(text)] = ""
  return(text)
}

# Helper function to generate an HTML table from a data frame
# Not exported.
# Helper function to generate an HTML table from a data frame
# Not exported.
.df_to_html_table = function(df) {
  if (is.null(df) || NROW(df) == 0) {
    return("<p><em>No data available.</em></p>")
  }

  # Header
  header_html <- paste0("<th>", .html_escape(names(df)), "</th>", collapse = "")
  header_html <- paste0("<thead><tr>", header_html, "</tr></thead>")

  # Body - process column by column in a vectorized manner
  td_cols <- lapply(df, function(col) {

    # 1. Handle list-columns (for nested data)
    if (is.list(col)) {
      # Convert each list element to a pretty JSON string
      cell_content <- sapply(col, function(item) {
        # Explicitly handle NA, which would otherwise become "null" in JSON
        if (is.atomic(item) && length(item) == 1 && is.na(item)) {
          return(NA_character_)
        }
        # Represent nulls or empty lists/dfs as empty JSON array for consistency
        if (is.null(item) || (is.list(item) && length(item) == 0) || (is.data.frame(item) && nrow(item) == 0)) {
           return("[]")
        }
        # Convert to JSON
        jsonlite::toJSON(item, pretty = TRUE, auto_unbox = TRUE)
      })

      is_na <- is.na(cell_content)
      escaped_content <- .html_escape(cell_content)
      html_cells <- ifelse(is_na, "<em>NA</em>", paste0("<pre>", escaped_content, "</pre>"))

    # 2. Handle atomic columns (including stringified JSON from diff reports)
    } else {
      cell_content <- as.character(col)
      is_na <- is.na(cell_content)
      # Check for strings that look like JSON objects or arrays
      is_json_like <- !is_na & (startsWith(cell_content, "{") | startsWith(cell_content, "["))
      escaped_content <- .html_escape(cell_content)
      # Apply formatting conditionally
      html_cells <- ifelse(is_na, "<em>NA</em>",
                           ifelse(is_json_like, paste0("<pre>", escaped_content, "</pre>"),
                                  escaped_content))
    }
    # Wrap all processed cells in <td> tags
    paste0("<td>", html_cells, "</td>")
  })

  # Combine columns into rows using vectorized paste
  if (length(td_cols) > 0) {
    body_rows <- do.call(paste0, td_cols)
  } else {
    body_rows <- rep("", NROW(df)) # Handles df with 0 columns
  }


  # Wrap each row in <tr> tags
  body_html <- paste0("<tr>", body_rows, "</tr>", collapse = "\n")
  body_html <- paste0("<tbody>\n", body_html, "\n</tbody>")

  # Final assembly
  paste(
    "<table>",
    header_html,
    body_html,
    "</table>",
    collapse = "\n"
  )
}

fp_report_css = function() {
  css = "
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; margin: 2em; color: #333; }
    h1 { color: #111; border-bottom: 2px solid #ccc; padding-bottom: 0.1em; }
    h2 { background-color: #eef; color: #333; padding: 0.1em; border-left: 5px solid #66b; margin-top: 0.1em;}
    .table-container { max-height: 600px; max-width: 100%; overflow: auto; border: 1px solid #ccc; margin-bottom: 0.5em; }
    table { border-collapse: collapse; font-size: 0.8em; white-space: nowrap; }
    th, td { border: 1px solid #ddd; padding: 4px 6px; text-align: left; vertical-align: top; }
    th { background-color: #f2f2f2; position: sticky; top: 0; z-index: 1; }
    tr:nth-child(even) { background-color: #f9f9f9; }
    tr:hover { background-color: #f1f1f1; }
    .trunc-info { font-style: italic; color: #888; font-size: 0.8em; margin-bottom: 1em;}
    em { color: #999; }
  "

}


#' Generate an HTML report for fuzzy products
#'
#' This function takes a set of version directories, loads the `prod_df.Rds`
#' from each, and compiles them into a single HTML report file. The report
#' is organized by product, process, and version. Each data frame is
#' displayed in a scrollable, styled table.
#'
#' @param ver_dirs A character vector of version directories. Typically generated by `fp_all_ok_ver_dirs`.
#' @param outfile The path for the output HTML file.
#' @param prods Optionally a list of product definitions (from `prods_define`) to determine the order of products in the report.
#' @param max_rows The maximum number of rows to display for each table.
#' @param max_cols The maximum number of columns to display for each table.
#' @param title The title of the HTML report.
#' @return The path to the created `outfile`, invisibly.
fp_html_report = function(ver_dirs, outfile=NULL, prods = NULL, max_rows=100, max_cols=50, title = "Fuzzy Production Report") {
  restore.point("fp_html_report")


  if (length(ver_dirs) == 0) {
    cat("No version directories provided to fp_html_report.")
    return(invisible(NULL))
  }

  if (is.null(outfile)) {
    fp_dir = fp_ver_dir_to_fp_dir(ver_dirs[1])
    outfile = file.path(fp_dir, "fp_report.html")
  }

  # 1. Get info for all ver_dirs and sort them
  info_df = fp_ver_dir_to_ids(ver_dirs)

  # Determine sorting order based on prods list if provided
  if (!is.null(prods)) {
      all_prod_ids = unique(info_df$prod_id)
      # Order by prods list, but only include products present in ver_dirs
      prod_order_from_prods = intersect(names(prods), all_prod_ids)
      # Add any other products from ver_dirs not in the prods list, sorted alphabetically
      other_prod_ids = sort(setdiff(all_prod_ids, prod_order_from_prods))
      final_prod_order = c(prod_order_from_prods, other_prod_ids)

      # Use a factor to enforce the custom sort order for prod_id
      info_df$prod_id = factor(info_df$prod_id, levels = final_prod_order)
  }

  # Sort the info data frame (by factor levels if prods was given, else alphabetically)
  info_df = dplyr::arrange(info_df, .data$prod_id, .data$proc_id, .data$ver_ind)


  # 2. Start building HTML content
  css = fp_report_css()

  html_head = paste0(
    "<!DOCTYPE html><html><head><meta charset='UTF-8'><title>", .html_escape(title), "</title>",
    "<style>", css, "</style></head><body><h1>", .html_escape(title), "</h1>"
  )

  html_body_parts = c()

  # 3. Iterate through sorted dirs, load data, and generate HTML for each table
  for (i in 1:NROW(info_df)) {
    row = info_df[i, ]
    ver_dir = row$ver_dir

    header = paste(as.character(row$prod_id), row$proc_id, paste0("v", row$ver_ind), sep = " / ")
    html_body_parts = c(html_body_parts, paste0("<h2>", .html_escape(header), "</h2>"))

    # Load prod_df
    df = tryCatch({
      fp_load_prod_df(ver_dir)
    }, error = function(e) {
      warning("Could not load prod_df from ", ver_dir, ": ", e$message)
      return(NULL)
    })

    if (is.null(df)) {
       html_body_parts = c(html_body_parts, "<p><em>Could not load data.</em></p>")
       next
    }

    # Truncate if necessary
    orig_rows = NROW(df)
    orig_cols = NCOL(df)

    df_display = df
    truncated = FALSE
    trunc_msg = c()

    if (orig_rows > max_rows) {
      df_display = df_display[1:max_rows, ]
      trunc_msg = c(trunc_msg, paste0("rows truncated to ", max_rows, " (from ", orig_rows, ")"))
      truncated = TRUE
    }
    if (orig_cols > max_cols) {
      df_display = df_display[, 1:max_cols, drop = FALSE]
      trunc_msg = c(trunc_msg, paste0("columns truncated to ", max_cols, " (from ", orig_cols, ")"))
      truncated = TRUE
    }

    # Generate table HTML
    table_html = .df_to_html_table(df_display)
    html_body_parts = c(html_body_parts, "<div class='table-container'>", table_html, "</div>")

    # Add truncation info message if needed
    if (truncated) {
        msg = paste0("<p class='trunc-info'>Note: ", paste(trunc_msg, collapse=", "), ".</p>")
        html_body_parts = c(html_body_parts, msg)
    }
  }

  html_foot = "</body></html>"

  # 4. Combine all parts and write to file
  final_html = paste(c(html_head, html_body_parts, html_foot), collapse="\n")
  writeLines(final_html, outfile)

  cat("HTML report written to:", outfile, "\n")
  invisible(outfile)
}
